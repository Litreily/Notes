# 进程调度

> Linux Kernel Development ch4: Process Scheduling

多任务操作系统的进程调度分为非抢占式调度和抢占式调度，现代操作系统基本上都采用了抢占式调度。

## Linux 进程调度

1. 2.4 kernel 调度器: 设计简单、粗糙，易于理解，但是难以胜任过多可执行进程
2. 2.5 kerenl 调度器：大型改造，O(1)调度器，算法优化
3. 2.6 kernel 调度器：针对交互进程，吸取队列理论，设计RSDL调度，后更新为Completely Fair Scheduler(CFS)

## 策略

`Policy`决定调度程序何时让什么进程运行。

### I/O 消耗型和处理器消耗型进程

- I/O 消耗型：大量的I/O请求，大部分时间在阻塞态等待I/O数据
- 处理器消耗型：大部分时间在执行代码，基本不阻塞去等待I/O，比如sshkeygen和MATLAB

进程可能同时包含以上两种行为。调度器策略需要尝试满足两种冲突需求：快速的进程响应和最大化系统利用率。为了实现这个目标，调度器使用了非常复杂的算法去决定最值得执行的进程。

Unix系统偏向于I/O消耗型进程，可以提供好的进程响应时间。Linux为了提供好的交互响应和桌面性能，优化了进程响应，更倾向于有优先调度I/O消耗型进程。


### 进程优先级

Linux采用两种优先级策略，nice值和实时优先级。

1. nice值：`-20 ~ 19`, nice值越小，优先级越高。 Linux系统使用`ps -el`，`NI`列对应的就是nice值，它代表时间片的比例。
2. 实时优先级：`0 ~ 90`, 与nice值相反，数值越高优先级越高。其值可配。查看实时进程的方式如下(rtprio)

```bash
ps -eo state,uid,pid,ppid,rtprio,time,comm
```

输出结果中`rtprio`为`-`代表不是实时进程。

!!! note
    1. 实时进程优先级高于普通进程
    2. Linux的实时优先级与nice优先级互不相交

### 时间片

调度器必须指定一个默认的时间片，但这并不简单。如果时间片过长，会导致系统交互性能变差，就感觉应用程序不是并发执行的。如果时间片过短，就会导致处理器浪费大量时间进行进程切换。同时I/O消耗型和处理器消耗型的矛盾也会显现，I/O消耗型的进程无需长的时间片，处理器消耗型的进程则相反。

较长时间片会导致系统性能低下，因此大多数操作系统的时间片都较短，比如10ms。Linux使用CFS调度器，不直接分配时间片给进程，而是将处理器使用比例分配给进程。在Linux中，进程处理时间由系统负载决定。此外，处理比例还与nice值有关系，nice值越高，处理器比例越低，反之亦然。

Linux系统是抢占式的，当一个进程进入可运行态，CFS调度器会根据分配给进程的处理比例去决定什么时候将其投入运行。如果比例低，则立即执行，抢占当前进程。否则延迟执行。

## 进程调度算法

### 调度器类

Linux调度器是模块化的，针对不同类型的进程，可以使用不同算法进行调度。这种模块化被称之为 **调度器类** (scheduler classes).调度器类允许不同的、可动态添加的调度方法去调度它们能够处理的进程。每个调度器类都有一个优先级。基本调度代码位于`kernel/sched.c`, 它会按照优先级顺序遍历调度类，拥有最高优先级的调度器类生出，并选择下面要执行的程序。

完全公平调度Completely Fair Scheduler(CFS)是用于常用进程的调度器类，在Linux系统中为`SCHED_NORMAL`, 位于`kernel/sched_fair.c`.

### Unix 系统中的进程调度

在UNIX系统中，优先级以nice值的方式输出到用户空间，这虽然看起来简单，但实际涉及很多反常问题。

首先，映射nice值到时间片需要确定每个nice值对应分配具体多大的时间片？假设有两个进程，一个是默认优先级(nice=0), 另一个是最低优先级(nice=20), 同时假设每个时间片最小单位为5ms. 那么两个进程的时间片分配如下：

| nice                 | timeslices | frequency |
| -------------------- | ---------- | --------- |
| 0 (default)          | 100ms      | 100 / 105 |
| 20 (lowest priority) | 5ms        | 5 / 105   |

如果有两个同等优先级(nice=20)的进程呢？按照上面的分配方式，每个进程都将获得5ms的时间片，然后每隔5ms切换一次，两个进程确实获得了50%的处理时间，但是切换过于频繁，大大浪费了CPU资源。以此类推，如果是两个普通进程，优先级nice=0, 它们同样可以获得50%的处理器时间，但是以100ms为增量。显然这种分配方式是不理想的，对于优先级不同的进程，虽然时间占比是合理的，但是实际的处理时间却是不理想的。

而且，通常高nice值(低优先级)的进程是后台进程，是计算密集型，需要连续执行较长时间，按照以上方式却将分得很少的时间片；而普通优先级进程多是前台用户任务，大多是I/O消耗型，大部分时间处于阻塞状态，按照以上方式却将获得更多的时间片。由此来看，以上分配方式是不合理的。

接下来看另外一个问题，同样是nice值相关的。

| nice | timeslices |
| ---- | ---------- |
| 0    | 100ms      |
| 1    | 95ms       |
| 18   | 10ms       |
| 19   | 5ms        |

nice值为0, 1的两个进程，时间片差5ms，但直观上看相差无几；但是nice值为18, 19的两个进程，时间片同样相差5ms，但却是相差两倍的处理器时间。由于nice值通常使用相对值（系统调用接受一个增量，而不是绝对值），这意味着“把进程的nice值减1”带来的影响很大程度取决于它的初始nice值。

第三个问题，如果需要映射nice值到时间片，就需要设定一个绝对的时间片。并且这个绝对值必须是内核可测量的。在大部分操作系统中，这意味着时间片必须是定时器节拍(timer tick)的整数倍。但这会引发几个问题，第一，最小时间片必须是定时器节拍的整数倍，可能是10ms，也可能是1ms；第二，系统定时器限制了时间片的差异：连续的nice值映射到时间片，差别多至10ms或者少则1ms；最后，时间片还随着定时器节拍不同而改变。

第四个问题，基于优先级的调度器可能为了优化交互任务而唤醒相关进程，这种系统中，可能为了进程能更快的投入运行，而去提升要唤醒的进程的优先级，即便它们的时间片已经耗尽。这样虽然可以提升交互性能，但也有可能给某些特殊的睡眠用例开了后门，打破了公平原则，获取更多处理器时间，损害了其它进程的利益。

上面的绝大多数问题通过改造Unix调度器都可以解决，比如将nice值呈几何增加而不是算数增加，这样可以解决上面第二个问题；使用新的度量机制将nice值到时间片的映射与定时器节拍分离，以解决第三个问题。但这些都没有解决实质问题——分配绝对的时间片引发的固定切换频率，给公平性造成很大变数。而CFS采用的方法是对时间片分配方式进行根本性的重新设计，完全摒弃时间片，并分配给进程一个处理器使用比重(proportion of the processor), 通过这种方式，CFS实现了完全公平调度，并将切换频率置于不断变换当中。
